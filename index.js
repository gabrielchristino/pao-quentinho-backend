// index.js

// Carrega as vari√°veis de ambiente do arquivo .env
require('dotenv').config();

// Log para depura√ß√£o da vari√°vel de ambiente do banco de dados
console.log(`[ENV] DATABASE_URL status: ${process.env.DATABASE_URL ? 'Encontrada' : 'N√ÉO ENCONTRADA'}`);

const express = require('express');
const webpush = require('web-push');
const cors = require('cors');
const cron = require('node-cron');
const { Pool } = require('pg'); // Importa o driver do PostgreSQL

const app = express();

// --- Configura√ß√£o do Banco de Dados ---
const pool = new Pool({
  connectionString: process.env.DATABASE_URL, // Usa a URL fornecida pelo Railway
  ssl: {
    rejectUnauthorized: false // Necess√°rio para conex√µes SSL em ambientes como Railway/Heroku
  }
});

// Middlewares
app.use(cors());
app.use(express.json());

// --- Configura√ß√£o das Notifica√ß√µes Push ---
// As chaves s√£o lidas das vari√°veis de ambiente do Railway
const VAPID_PUBLIC_KEY = process.env.VAPID_PUBLIC_KEY;
const VAPID_PRIVATE_KEY = process.env.VAPID_PRIVATE_KEY;

if (VAPID_PUBLIC_KEY && VAPID_PRIVATE_KEY) {
  webpush.setVapidDetails(
    'mailto:seu-email@exemplo.com', // Um email de contato
    VAPID_PUBLIC_KEY,
    VAPID_PRIVATE_KEY
  );
  console.log('‚úÖ Configura√ß√£o do Web Push realizada com sucesso.');
} else {
  console.warn("‚ö†Ô∏è Chaves VAPID n√£o configuradas. O envio de notifica√ß√µes est√° desabilitado.");
}

// --- Rotas da API ---

// Rota para fornecer a chave p√∫blica VAPID para o frontend
app.get('/api/vapid-public-key', (req, res) => {
  console.log('‚û°Ô∏è  GET /api/vapid-public-key');
  res.status(200).send(VAPID_PUBLIC_KEY);
});

app.get('/api/estabelecimentos', async (req, res) => {
  const userLat = parseFloat(req.query.lat);
  const userLng = parseFloat(req.query.lng);

  console.log(`‚û°Ô∏è  GET /api/estabelecimentos para lat: ${userLat}, lng: ${userLng}`);

  try {
    const result = await pool.query('SELECT id, nome, tipo, latitude, longitude, details FROM estabelecimentos');
    console.log(`[DB] Encontrados ${result.rowCount} estabelecimentos.`);
    
    // Remonta o objeto completo que o frontend espera
    let estabelecimentos = result.rows.map(row => ({
      id: row.id,
      nome: row.nome,
      tipo: row.tipo,
      latitude: row.latitude,
      longitude: row.longitude,
      ...row.details // Combina com os detalhes do JSONB (horario, endereco, etc.)
    }));
    
    // Se as coordenadas do usu√°rio foram fornecidas, calcula a dist√¢ncia
    if (!isNaN(userLat) && !isNaN(userLng)) {
      const estabelecimentosComDistancia = estabelecimentos.map(est => {
        const distanciaKm = calculateDistance(userLat, userLng, est.latitude, est.longitude);
        return { ...est, distanciaKm };
      });
      // Ordena pela dist√¢ncia
      res.status(200).json(estabelecimentosComDistancia.sort((a, b) => a.distanciaKm - b.distanciaKm));
    } else {
      // Retorna a lista sem dist√¢ncia se as coordenadas n√£o forem fornecidas
      res.status(200).json(estabelecimentos);
    }
  } catch (err) {
    console.error('‚ùå Erro ao buscar estabelecimentos:', err.stack);
    res.status(500).json({ message: 'Erro ao buscar estabelecimentos.' });
  }
});

app.get('/api/estabelecimentos/:id', async (req, res) => {
  const { id } = req.params;
  console.log(`‚û°Ô∏è  GET /api/estabelecimentos/${id}`);

  try {
    const result = await pool.query('SELECT id, nome, tipo, latitude, longitude, details FROM estabelecimentos WHERE id = $1', [id]);

    if (result.rowCount === 0) {
      return res.status(404).json({ message: 'Estabelecimento n√£o encontrado.' });
    }

    const row = result.rows[0];
    // Remonta o objeto completo que o frontend espera
    const estabelecimento = {
      id: row.id,
      nome: row.nome,
      tipo: row.tipo,
      latitude: row.latitude,
      longitude: row.longitude,
      ...row.details
    };

    res.status(200).json(estabelecimento);
  } catch (err) {
    console.error(`‚ùå Erro ao buscar o estabelecimento ${id}:`, err.stack);
    res.status(500).json({ message: 'Erro ao buscar o estabelecimento.' });
  }
});

app.post('/api/subscribe', async (req, res) => {
  const { subscription, estabelecimentoId } = req.body;
  console.log(`‚û°Ô∏è  POST /api/subscribe para o estabelecimento ${estabelecimentoId}`);

  try {
    // 1. Insere a inscri√ß√£o se ela n√£o existir e retorna o ID dela.
    const upsertSubscriptionQuery = `
      INSERT INTO subscriptions (subscription_data) VALUES ($1)
      ON CONFLICT (subscription_data) DO UPDATE SET subscription_data = EXCLUDED.subscription_data
      RETURNING id;
    `;
    const subResult = await pool.query(upsertSubscriptionQuery, [subscription]);
    const subscriptionId = subResult.rows[0].id;

    // 2. Cria a liga√ß√£o entre a inscri√ß√£o e o estabelecimento.
    const linkQuery = `
      INSERT INTO establishment_subscriptions (subscription_id, estabelecimento_id) VALUES ($1, $2)
      ON CONFLICT (subscription_id, estabelecimento_id) DO NOTHING;
    `;
    await pool.query(linkQuery, [subscriptionId, estabelecimentoId]);

    res.status(201).json({ message: 'Inscri√ß√£o realizada com sucesso.' });
  } catch (err) {
    console.error('‚ùå Erro ao salvar inscri√ß√£o:', err.stack);
    res.status(500).json({ message: 'Erro ao salvar inscri√ß√£o.' });
  }
});

app.post('/api/notify/:estabelecimentoId', async (req, res) => {
    const { estabelecimentoId } = req.params;
    const { message, title } = req.body || {}; // Garante que req.body n√£o seja nulo

    console.log(`‚û°Ô∏è  POST /api/notify/${estabelecimentoId} - Disparando notifica√ß√£o manual...`);

    try {
        // Busca as inscri√ß√µes para um estabelecimento espec√≠fico, fazendo o JOIN com a tabela de jun√ß√£o
        const query = `
          SELECT s.subscription_data
          FROM subscriptions s
          JOIN establishment_subscriptions es ON s.id = es.subscription_id
          WHERE es.estabelecimento_id = $1;
        `;
        const result = await pool.query(query, [estabelecimentoId]);
        const subscriptions = result.rows.map(row => row.subscription_data);

        if (subscriptions.length === 0) {
          console.log(`[NOTIFY] Nenhum inscrito encontrado para o estabelecimento ${estabelecimentoId}.`);
          return res.status(200).json({ message: 'Nenhum inscrito encontrado para este estabelecimento.' });
        }

        let notificationBody = message;

        // Se nenhuma mensagem foi enviada no corpo da requisi√ß√£o, busca uma aleat√≥ria no banco
        if (!notificationBody) {
          console.log('[NOTIFY] Nenhuma mensagem fornecida. Buscando mensagem aleat√≥ria no banco de dados...');
          const messagesResult = await pool.query('SELECT message FROM notification_messages');
          const randomMessages = messagesResult.rows;

          if (randomMessages.length > 0) {
            notificationBody = randomMessages[Math.floor(Math.random() * randomMessages.length)].message;
            console.log(`[NOTIFY] Mensagem aleat√≥ria selecionada: "${notificationBody}"`);
          }
        }

        const notificationPayload = {
            notification: {
                title: title || 'P√£o Quentinho!',
                body: notificationBody || 'Uma nova fornada acabou de sair! Venha conferir!', // Fallback final
                icon: 'https://gabriel-nt.github.io/pao-quentinho/assets/icons/icon-192x192.png',
                vibrate: [100, 50, 100],
                data: {
                    url: `https://gabriel-nt.github.io/pao-quentinho/estabelecimento/${estabelecimentoId}` 
                }
            }
        };

        const promises = subscriptions.map(sub =>
            webpush.sendNotification(sub, JSON.stringify(notificationPayload))
        );

        // Usamos Promise.allSettled para lidar com sucessos e falhas individualmente
        const results = await Promise.allSettled(promises);

        // Limpeza de inscri√ß√µes expiradas
        results.forEach((result, index) => {
          if (result.status === 'rejected' && result.reason.statusCode === 410) {
            const expiredSubscription = subscriptions[index];
            const endpoint = expiredSubscription.endpoint;
            console.log(`üóëÔ∏è  Inscri√ß√£o expirada detectada. Removendo do banco de dados: ${endpoint}`);
            // A cl√°usula ON DELETE CASCADE no banco de dados cuidar√° de remover as entradas na tabela de jun√ß√£o.
            pool.query("DELETE FROM subscriptions WHERE subscription_data->>'endpoint' = $1", [endpoint])
              .catch(err => console.error(`‚ùå Erro ao remover inscri√ß√£o expirada: ${err.stack}`));
          }
        });

        console.log(`‚úÖ Notifica√ß√µes manuais enviadas para ${subscriptions.length} inscritos.`);
        res.status(200).json({ message: `Notifica√ß√µes enviadas para ${subscriptions.length} inscritos.` });
    } catch (err) {
        console.error("‚ùå Erro ao enviar notifica√ß√µes manuais:", err);
        res.status(500).json({ message: 'Erro ao enviar notifica√ß√µes.' });
    }
});

// Fun√ß√£o para testar a conex√£o com o banco de dados com tentativas
const connectWithRetry = async (retries = 5, delay = 5000) => {
  for (let i = 0; i < retries; i++) {
    try {
      const client = await pool.connect();
      console.log('‚úÖ [DB] Conex√£o com o banco de dados estabelecida com sucesso.');
      client.release(); // Libera o cliente de volta para o pool
      return;
    } catch (err) {
      console.error(`‚ùå Erro ao conectar ao banco de dados (tentativa ${i + 1}):`, err.message);
      if (i < retries - 1) {
        console.log(`Tentando novamente em ${delay / 1000} segundos...`);
        await new Promise(res => setTimeout(res, delay));
      } else {
        throw new Error('N√£o foi poss√≠vel conectar ao banco de dados ap√≥s v√°rias tentativas.');
      }
    }
  }
};

/**
 * Fun√ß√£o que verifica as pr√≥ximas fornadas e dispara notifica√ß√µes.
 * Esta fun√ß√£o ser√° agendada para rodar a cada 15 minutos.
 */
const checkFornadasAndNotify = async () => {
  console.log('‚è∞ [CRON] Verificando fornadas agendadas...');

  try {
    const result = await pool.query('SELECT id, nome, details FROM estabelecimentos');
    const estabelecimentos = result.rows;
    // traz o resultado da consulta
    console.log(`[DB] Encontrados ${estabelecimentos.length} estabelecimentos.`);

    // Otimiza√ß√£o: Busca todas as mensagens aleat√≥rias de uma vez, fora do loop
    const messagesResult = await pool.query('SELECT message FROM notification_messages');
    const randomMessages = messagesResult.rows;
    console.log(`[DB] Encontradas ${randomMessages.length} mensagens de notifica√ß√£o.`);

    // Obt√©m a hora e os minutos atuais de forma robusta no fuso hor√°rio de S√£o Paulo.
    const now = new Date();
    const timeParts = new Intl.DateTimeFormat('en-US', {
      timeZone: 'America/Sao_Paulo',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    }).formatToParts(now);

    const currentHours = parseInt(timeParts.find(p => p.type === 'hour')?.value || '0', 10);
    const currentMinutes = parseInt(timeParts.find(p => p.type === 'minute')?.value || '0', 10);
    const currentMinutesSinceMidnight = (currentHours * 60) + currentMinutes;

    for (const est of estabelecimentos) {
      const proximaFornada = est.details.proximaFornada;
      // traz o hor√°rio
      console.log(`[CRON] Estabelecimento ${est.id} (${est.nome}) - Pr√≥xima fornada: ${proximaFornada}`);

      // Ignora se n√£o houver hor√°rio de fornada
      if (!proximaFornada || proximaFornada === 'N/A') {
        continue;
      }

      const [fornadaHours, fornadaMinutes] = proximaFornada.split(':').map(Number);
      const fornadaTotalMinutes = (fornadaHours * 60) + fornadaMinutes;
      console.log(`[CRON] Estabelecimento ${est.id} (${est.nome}) - Fornada √†s ${fornadaHours}:${fornadaMinutes} (${fornadaTotalMinutes} min do dia)`);

      // Calcula os minutos desde a meia-noite para os hor√°rios de notifica√ß√£o
      const notification1hBefore = fornadaTotalMinutes - 60; // 1 hora antes
      const notification5minBefore = fornadaTotalMinutes - 5;   // 5 minutos antes

      // Verifica se o minuto atual est√° na janela de algum dos hor√°rios de notifica√ß√£o
      // A janela de 5 minutos (ex: `+ 5`) √© para garantir que a notifica√ß√£o seja pega pelo cron que roda a cada 5 min.
      const shouldNotify1h = currentMinutesSinceMidnight >= notification1hBefore && currentMinutesSinceMidnight < notification1hBefore + 5;
      const shouldNotify5min = currentMinutesSinceMidnight >= notification5minBefore && currentMinutesSinceMidnight < notification5minBefore + 5;

      if (shouldNotify1h || shouldNotify5min) {
        console.log(`üî• Hora de notificar para a fornada das ${proximaFornada} no estabelecimento ${est.id} (${est.nome})!`);
        
        const isAlmostTime = shouldNotify5min;

        // Busca as inscri√ß√µes para o estabelecimento espec√≠fico
        const subscriptionsQuery = `
          SELECT s.subscription_data
          FROM subscriptions s
          JOIN establishment_subscriptions es ON s.id = es.subscription_id
          WHERE es.estabelecimento_id = $1;
        `;
        const subscriptionsResult = await pool.query(subscriptionsQuery, [est.id]);
        const subscriptions = subscriptionsResult.rows.map(row => row.subscription_data);
        console.log(`[CRON] Encontradas ${subscriptions.length} inscri√ß√µes para o estabelecimento ${est.id}.`);

        if (subscriptions.length > 0) {
          // Seleciona uma mensagem aleat√≥ria da lista j√° buscada
          const randomMessage = randomMessages.length > 0
            ? randomMessages[Math.floor(Math.random() * randomMessages.length)].message.replace('P√£o quentinho', 'P√£o quentinho saindo')
            : `Uma nova fornada sair√° √†s ${proximaFornada}. N√£o perca!`;

          console.log(`[CRON] Mensagem selecionada para notifica√ß√£o: "${randomMessage}"`);

          const notificationPayload = {
            notification: {
              title: isAlmostTime ? `Est√° saindo agora em ${est.nome}!` : `Falta 1h para a fornada em ${est.nome}!`,
              body: randomMessage,
              icon: 'https://gabriel-nt.github.io/pao-quentinho/assets/icons/icon-192x192.png',
              data: {
                url: `https://gabriel-nt.github.io/pao-quentinho/estabelecimento/${est.id}`
              }
            }
          };

          console.log(`[CRON] Enviando notifica√ß√µes para ${subscriptions.length} inscritos do estabelecimento ${est.id}...`);

          const promises = subscriptions.map(sub =>
            webpush.sendNotification(sub, JSON.stringify(notificationPayload))
          );

          const results = await Promise.allSettled(promises);

          results.forEach((result, index) => {
            if (result.status === 'rejected' && result.reason.statusCode === 410) {
              const expiredSubscription = subscriptions[index];
              const endpoint = expiredSubscription.endpoint;
              console.log(`üóëÔ∏è  [CRON] Inscri√ß√£o expirada detectada. Removendo: ${endpoint}`);
              pool.query("DELETE FROM subscriptions WHERE subscription_data->>'endpoint' = $1", [endpoint])
                .catch(err => console.error(`‚ùå [CRON] Erro ao remover inscri√ß√£o expirada: ${err.stack}`));
            }
          });
          console.log(`‚úÖ Notifica√ß√µes enviadas para ${subscriptions.length} inscritos do estabelecimento ${est.id}.`);
        }
      }
    }
  } catch (err) {
    console.error('‚ùå [CRON] Erro ao verificar fornadas:', err);
  }
};

/**
 * Calcula a dist√¢ncia em KM entre duas coordenadas geogr√°ficas usando a f√≥rmula de Haversine.
 */
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Raio da Terra em km
  const dLat = deg2rad(lat2 - lat1);
  const dLon = deg2rad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c; // Dist√¢ncia em km
}

/**
 * Converte graus para radianos.
 */
function deg2rad(deg) {
  return deg * (Math.PI / 180);
}

// --- Inicializa√ß√£o do Servidor ---
const startServer = async () => {
  try {
    // Valida√ß√£o "Fail-Fast": Garante que vari√°veis essenciais existam antes de continuar.
    if (!process.env.DATABASE_URL) {
      throw new Error('DATABASE_URL n√£o foi encontrada nas vari√°veis de ambiente.');
    }

    await connectWithRetry();
    const PORT = process.env.PORT || 3000;
    app.listen(PORT, () => {
      console.log(`üöÄ Servidor iniciado e rodando na porta ${PORT}`);

      // Agenda a verifica√ß√£o de fornadas para rodar a cada 5 minutos.
      cron.schedule('*/5 * * * *', checkFornadasAndNotify, { timezone: "America/Sao_Paulo" });
    });
  } catch (err) {
    console.error('üî• Falha ao iniciar o servidor:', err.message);
    process.exit(1); // Encerra a aplica√ß√£o se n√£o conseguir conectar ao DB
  }
};

startServer();
